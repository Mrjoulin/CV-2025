# Адаптивная бинаризация изображений

## Теоретическая база

### Адаптивная бинаризация

Адаптивная бинаризация - это метод пороговой обработки изображений, при котором порог вычисляется локально для каждого пикселя на основе характеристик его окрестности. В отличие от глобальной бинаризации, этот подход эффективен для изображений с неравномерным освещением.

### Математическая основа

Для пикселя I(x,y) с координатами (x,y) адаптивный порог T(x,y) вычисляется как:
T(x,y) = μ(x,y) - C

где:
- μ(x,y) - среднее значение в окрестности пикселя
- C - константа (обычно положительная)

### Методы вычисления локального порога

1. Mean (усреднение):
μ(x,y) = mean(I(x-i,y-j)) для i,j ∈ [-k,k]

2. Gaussian (взвешенное усреднение):
μ(x,y) = ΣΣ I(x-i,y-j) * G(i,j) / ΣΣ G(i,j)

где G(i,j) - гауссово ядро

## Описание разработанной системы

### Алгоритмы

Программа реализует два алгоритма адаптивной бинаризации:

1. Mean метод:
- Вычисляет среднее арифметическое в квадратной окрестности
- Прост в реализации и вычислениях

2. Gaussian метод:
- Использует гауссово взвешивание для плавного усреднения
- Более устойчив к шуму

### Архитектура системы
AdaptiveThreshold
├── adaptive_threshold_opencv() # Реализация с OpenCV
├── adaptive_threshold_native_mean() # Нативная mean реализация
└── adaptive_threshold_native_gaussian() # Нативная gaussian реализация

### Принципы работы

1. OpenCV реализация: использует оптимизированные функции cv2.adaptiveThreshold
2. Нативная реализация: поэлементная обработка с циклами Python/NumPy
3. Сравнение: измерение времени выполнения и визуальная оценка качества

## Результаты работы и тестирования

### Пример работы программы
=== РЕЗУЛЬТАТЫ СРАВНЕНИЯ ===

MEAN МЕТОД:
OpenCV время: 0.0012 сек
Нативное время: 1.4567 сек
Ускорение OpenCV: 1213.92x
Разница результатов: 0.0234%

GAUSSIAN МЕТОД:
OpenCV время: 0.0013 сек
Нативное время: 3.8923 сек
Ускорение OpenCV: 2994.08x
Разница результатов: 0.0456%

### Визуальные результаты

![Сравнение результатов](results_comparison.png)

### Анализ производительности

![Анализ производительности](performance_analysis.png)

Наблюдаемые закономерности:

1. OpenCV значительно быстрее нативной реализации (в 1000+ раз)
2. Gaussian метод сложнее и требует больше времени
3. С ростом размера блока время выполнения увеличивается
4. Разница в результатах минимальна (< 0.1%)

## Выводы по работе

1. Производительность: OpenCV демонстрирует исключительную эффективность благодаря оптимизированным C++ реализациям и векторным операциям.

2. Точность: Обе реализации дают практически идентичные результаты, что подтверждает корректность алгоритмов.

3. Практическое применение: Для реальных задач рекомендуется использовать OpenCV версию из-за значительно лучшей производительности.

4. Образовательная ценность: Нативная реализация полезна для понимания принципов работы алгоритма, но не подходит для production-систем.

5. Оптимизация: Основные направления оптимизации - векторизация вычислений, использование кэша и параллелизация.

## Использованные источники

1. OpenCV Documentation: Adaptive Thresholding
2. Bradski, G., & Kaehler, A. (2008). Learning OpenCV
3. Gonzalez, R. C., & Woods, R. E. (2018). Digital Image Processing
4. NumPy Documentation: Vectorization techniques
